# CAS原理



## 1 什么是CAS

**CAS，是Compare and Swap(比较换算)的简称**，**是乐观锁的典型实现**,在这个机制中有三个核心的参数：

- **V表示变量当前的值**
- **E表示预期的值**
- **N表示新值**



## 2 CAS核心思想

**一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值**,**如果失败了,什么都不做或者重试**

### 2.1 流程图

![](http://dist415.oss-cn-beijing.aliyuncs.com/cas.png)

### 2.2 CAS解决的问题

值得注意的是CAS机制中的这步步骤是原子性的（**从指令层面提供的原子操作**），**所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题**。



## 3 CAS的优点

- 可以保证变量操作的原子性；

- 并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；
- 在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。



## 4 CAS的缺点

- **ABA问题**
- **自旋导致的消耗较高的CPU**
- **只能保证一个共享变量的原子操作,不能保证代码块的原子性**

### 4.1 ABA问题

#### 4.1.1 描述

ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。

#### 4.1.2 解决方法

为了解决这个问题，在**每次进行操作的时候加上一个版本号，每次操作的就是两个值**，一个版本号和某个值，对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。

![](http://dist415.oss-cn-beijing.aliyuncs.com/casaba.png)



### 4.2 自旋导致大量消耗CPU

#### 4.2.1 描述

看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。**这种情况下CAS机制会一直重试，这样就会比较耗费CPU。**

#### 4.2.2 解决方法

- **限制重试次数**
- **如果可以使用CPU的延时流水线指令(de-pipeline)**



### 4.3 不能保证代码块的原子性

#### 4.3.1 描述

**CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效**。

#### 4.3.2 解决方法

- 但是从 JDK 1.5开始，提供了`AtomicReference`类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference`类把多个共享变量合并成一个共享变量来操作。
- golang提供了`sync/atomic`包来解决此问题



