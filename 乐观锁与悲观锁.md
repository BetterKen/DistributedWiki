# 乐观锁与悲观锁

## 1 悲观锁定义

**Pessimistic Lock**：

每次获取数据的时候，都会担心数据被修改，所以**每次获取数据的时候都会进行加锁**，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，**期间对该数据进行读写的其他线程都会进行等待**。

## 2 乐观锁定义

每次获取数据的时候，都不会担心数据被修改，**所以每次获取数据的时候都不会进行加锁**，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。**由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作**。



## 3 适用场景

- **悲观锁**：比较适合**写入操作比较频繁**的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。
- **乐观锁**：比较适合**读取操作比较频繁**的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。



## 4 悲观锁的实现

**使用应用自带的锁机制,一般都是悲观锁机制**

如:Java中**synchronized和ReentrantLock**等独占锁就是悲观锁思想的实现



## 5 乐观锁的实现

使用CAS机制实现



## 6 总结

![](http://dist415.oss-cn-beijing.aliyuncs.com/dislock.png)

