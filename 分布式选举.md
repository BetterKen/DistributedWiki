# 分布式选举

## 1 为什么要有分布式选举

**主节点，在一个分布式集群中负责对其他节点的协调和管理，也就是说，其他节点都必须听**
**从主节点的安排。**
主节点的存在，就可以保证其他节点的有序运行，以及数据库集群中的写入数据在每个节点
上的一致性。这里的一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况。
当然，如果主故障了，集群就会天下大乱，就好比一个国家的皇帝驾崩了，国家大乱一样。
比如，数据库集群中主节点故障后，可能导致每个节点上的数据会不一致。
**这，就应了那句话“国不可一日无君”，对应到分布式系统中就是“集群不可一刻无主”。**

**总结来说，选举的作用就是选出一个主节点，由它来协调和管理其他节点，以保证集群有序**
**运行和节点间数据的一致性。**



## 2 分布式选举常见算法

- **Bully算法**
- **Raft算法**
- **ZAB算法**
- **Base Paxos**
- **Multi Paxos**



## 3 长者为大：Bully 算法

Bully 算法是一种霸道的集群选主算法，为什么说是霸道呢？

**因为它的选举原则是“长者”为大，即在所有活着的节点中，选取 ID 最大的节点作为主节点。**

在 Bully 算法中，节点的角色有两种：

- 普通节点
- 主节点

初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。
**当且仅当主节点故障或与其他节点失去联系后，才会重新选主。**

Bully 算法在选举过程中，需要用到以下 3 种消息：

- **Election 消息，用于发起选举；**
- **Alive 消息，对 Election 消息的应答；**
- **Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。**

Bully 算法选举的原则是“长者为大”，意味着它的假设条件是，集群中每个节点均知道其他节点的 ID。在此前提下，其具体的选举过程是:

1. 集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；
2. 如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复；
3. 若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；
4. 若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。



![](http://dist415.oss-cn-beijing.aliyuncs.com/disbully.png)



目前已经有很多开源软件采用了 Bully 算法进行选主，比如 MongoDB 的副本集故障转移功能。MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。

小结一下。**Bully 算法的选择特别霸道和简单，谁活着且谁的 ID 最大谁就是主节点，其他节点必须无条件服从。这种算法的优点是，选举速度快、算法复杂度低、简单易实现。**
**但这种算法的缺点在于，需要每个节点有全局的节点信息，因此额外信息存储较多；其次，任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。**

## 4 民主投票：Raft 算法

Raft 算法是典型的多数派投票选举算法，其选举机制与我们日常生活中的民主投票机制类似，核心思想是“少数服从多数”。也就是说，Raft 算法中，获得投票最多的节点成为主。

采用 Raft 算法选举，集群节点的角色有 3 种：

- **Leader**，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；
- **Candidate**，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 Leader；
- **Follower**，Leader 的跟随者，不可以发起选举。



Raft 选举的流程，可以分为以下几步：

1. 初始化时，**所有节点均为 Follower 状态**。
2. 开始选主时，所有节点的状态由 **Follower 转化为 Candidate**，并向其他节点发送选举请求。
3. 其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。**这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。**
4. 若发起选举请求的节点**获得超过一半的投票，则成为主节点**，其状态转化为 Leader，其他节点的状态则由Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。
5. **当 Leader 节点的任期到了**，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。

![](http://dist415.oss-cn-beijing.aliyuncs.com/disraft.png)



**请注意，每一轮选举，每个节点只能投一次票**。这种选举就类似人大代表选举，正常情况下每个人大代表都有一定的任期，任期到后会触发重新选举，且投票者只能将自己手里唯一的票投给其中一个候选者。对应到 Raft 算法中，选主是周期进行的，包括选主和任值两个时间段，选主阶段对应投票阶段，任值阶段对应节点成为主之后的任期。**但也有例外的时候，如果主节点故障，会立马发起选举，重新选出一个主节点。**

Google 开源的 Kubernetes，擅长容器管理与调度，为了保证可靠性，通常会部署 3 个节点用于数据备份。这 3 个节点中，有一个会被选为主，其他节点作为备。Kubernetes 的选主采用的是开源的 etcd 组件。而，etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的。

小结一下。

**Raft 算法具有选举速度快、算法复杂度低、易于实现的优点；**

**缺点是，它要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大。该算法选举稳定性比 Bully 算法好，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。**